#ifndef	_RX_DBC_ORA_PARAMETER_H_
#define	_RX_DBC_ORA_PARAMETER_H_

namespace rx_dbc_ora
{
    //-----------------------------------------------------
    //sql语句绑定参数,即可用于输入,也可用于输出
    //对于批量模式,参数对象对应着一个列的多行值,通过use_bulk()进行调整
    class sql_param_t:public col_base_t
    {
        friend class stmt_t;
        ub4                 m_max_bulk_count;               //最大的批量数
        conn_t		        *m_conn;		                //关联的数据库连接对象
        ub2                 m_bulk_idx;                     //当前操作的行块序号

        //-------------------------------------------------
        sql_param_t(const sql_param_t&);
        sql_param_t& operator = (const sql_param_t&);

        //-------------------------------------------------
        //释放全部的资源
        void clear(void)
        {
            col_base_t::reset();
            m_max_bulk_count = 0;
            m_bulk_idx = 0;
        }

        //-------------------------------------------------
        //进行数据类型确认并进行数据初始化
        void m_init_data_type(const char *param_name, data_type_t type, int StringMaxSize, ub4 BulkCount)
        {
            rx_assert(!is_empty(param_name));
            rx_assert(m_max_bulk_count == (ub4)0);
            rx_assert(BulkCount >= 1);
            m_max_bulk_count = BulkCount;

            ub2 oci_data_type;
            data_type_t	dbc_data_type;
            int max_data_size;

            char NamePreDateTypeChar = ' ';                   //默认前缀无效
            if (param_name[0] == ':')
                NamePreDateTypeChar = param_name[1];          //以':'为前导的参数命名才进行前缀类型解析

            //根据外面告知的绑定数据类型,进行内部数据类型转换
            if (type == DT_NUMBER || (type == DT_UNKNOWN && NamePreDateTypeChar == PP_NUMERIC))
            {
                dbc_data_type = DT_NUMBER;
                oci_data_type = SQLT_VNU;
                max_data_size = sizeof(OCINumber);
            }
            else if (type == DT_DATE || (type == DT_UNKNOWN && NamePreDateTypeChar == PP_DATE))
            {
                dbc_data_type = DT_DATE;
                oci_data_type = SQLT_ODT;
                max_data_size = sizeof(OCIDate);
            }
            else if (type == DT_TEXT || (type == DT_UNKNOWN && NamePreDateTypeChar == PP_TEXT))
            {
                dbc_data_type = DT_TEXT;
                oci_data_type = SQLT_STR;
                max_data_size = StringMaxSize;
            }
            else
                //该类型当前还不能处理
                throw (error_info_t(DBEC_BAD_TYPEPREFIX, __FILE__, __LINE__, param_name));


            //分配参数数据内存,并初始清零
            col_base_t::make(param_name, strlen(param_name), oci_data_type, dbc_data_type, max_data_size, BulkCount, true);

            for (ub4 i = 0; i < BulkCount; i++)
            {
                m_col_dataempty.at(i) = -1;
                m_col_datasize.at(i) = 0;
            }
        }

        //-------------------------------------------------
        //初始化绑定到对应的语句句柄上
        void bind(conn_t &conn, OCIStmt* StmtHandle, const char *name, data_type_t type, int StringMaxSize, int BulkCount)
        {
            rx_assert(!is_empty(name));
            clear();
            try
            {
                m_conn = &conn;

                //可以根据参数名前缀额外处理参数数据类型,如果没有明确设置参数类型的话
                m_init_data_type(name, type, StringMaxSize, BulkCount);

                //OCI绑定句柄,无需释放
                OCIBind	*bind_handle=NULL;                     

                sword result = OCIBindByName(StmtHandle, &bind_handle, conn.m_handle_err, (text *)name, (ub4)rx::st::strlen(name),
                    m_col_databuff.array(), m_max_data_size,
                    m_oci_data_type, m_col_dataempty.array(), m_col_datasize.array(),
                    NULL,	// pointer conn array of field_t-level return codes
                    0,		// maximum possible number of elements of type m_nType
                    NULL,	// a pointer conn the actual number of elements (PL/SQL binds)
                    OCI_DEFAULT);

                if (result != OCI_SUCCESS)
                    throw (error_info_t(result, conn.m_handle_err, __FILE__, __LINE__, name));
            }
            catch (...)
            {
                clear();
                throw;
            }
        }
        //-------------------------------------------------
        //绑定数字值
        sql_param_t& set_long(int32_t value, bool is_signed)
        {
            rx_assert_msg(m_bulk_idx < m_max_bulk_count, "索引下标越界!已经使用bulk_bind_begin预先描述了吗?");
            switch (m_dbc_data_type)
            {
            case DT_NUMBER:
            {
                rx_assert(m_max_data_size == sizeof(OCINumber));
                ub1* data_buff = &m_col_databuff.at(m_bulk_idx*m_max_data_size);   //得到可用缓冲区
                sword result = OCINumberFromInt(m_conn->m_handle_err, &value, sizeof(int32_t), is_signed ? OCI_NUMBER_SIGNED : OCI_NUMBER_UNSIGNED, reinterpret_cast <OCINumber *> (data_buff));
                if (result != OCI_SUCCESS)
                    throw (error_info_t(result, m_conn->m_handle_err, __FILE__, __LINE__));
                m_col_dataempty.at(m_bulk_idx) = 0;              //标记参数非空了
                m_col_datasize.at(m_bulk_idx) = m_max_data_size; //记录数据的实际长度
                return (*this);
            }
            case DT_TEXT:
            {
                char tmp_buff[50];
                if (is_signed)
                    sprintf(tmp_buff, "%d", value);
                else
                    sprintf(tmp_buff, "%u", value);
                return set_string(tmp_buff);
            }
            default:
                throw (error_info_t(DBEC_BAD_INPUT, __FILE__, __LINE__));
            }
        }
        //-------------------------------------------------
        //绑定大数字与浮点数
        sql_param_t& set_double(double value)
        {
            rx_assert_msg(m_bulk_idx < m_max_bulk_count, "索引下标越界!已经使用bulk_bind_begin预先描述了吗?");
            switch (m_dbc_data_type)
            {
            case DT_NUMBER:
            {
                rx_assert(m_max_data_size == sizeof(OCINumber));
                ub1* data_buff = &m_col_databuff.at(m_bulk_idx*m_max_data_size);   //得到可用缓冲区
                sword result = OCINumberFromReal(m_conn->m_handle_err, &value, sizeof(double), reinterpret_cast <OCINumber *> (data_buff));
                if (result != OCI_SUCCESS)
                    throw (error_info_t(result, m_conn->m_handle_err, __FILE__, __LINE__));
                m_col_dataempty.at(m_bulk_idx) = 0;                 //标记参数非空了
                m_col_datasize.at(m_bulk_idx) = m_max_data_size;    //记录数据的实际长度
                return (*this);
            }
            case DT_TEXT:
            {
                char tmp_buff[50];
                sprintf(tmp_buff, "%f", value);
                return set_string(tmp_buff);
            }
            default:
                throw (error_info_t(DBEC_BAD_INPUT, __FILE__, __LINE__));
            }
        }
        sql_param_t& set_real(long double value)
        {
            rx_assert_msg(m_bulk_idx < m_max_bulk_count, "索引下标越界!已经使用bulk_bind_begin预先描述了吗?");
            switch (m_dbc_data_type)
            {
            case DT_NUMBER:
            {
                rx_assert(m_max_data_size == sizeof(OCINumber));
                ub1* data_buff = &m_col_databuff.at(m_bulk_idx*m_max_data_size);
                sword result = OCINumberFromReal(m_conn->m_handle_err, &value, sizeof(value), reinterpret_cast <OCINumber *> (data_buff));
                if (result != OCI_SUCCESS)
                    throw (error_info_t(result, m_conn->m_handle_err, __FILE__, __LINE__));
                m_col_dataempty.at(m_bulk_idx) = 0;                 //标记参数非空了
                m_col_datasize.at(m_bulk_idx) = m_max_data_size;    //记录数据的实际长度
                return (*this);
            }
            case DT_TEXT:
            {
                char tmp_buff[50];
                sprintf(tmp_buff, "%Lf", value);
                return set_string(tmp_buff);
            }
            default:
                throw (error_info_t(DBEC_BAD_INPUT, __FILE__, __LINE__));
            }
            
        }
        //-------------------------------------------------
        //绑定日期数据
        sql_param_t& set_datetime(const datetime_t& d)
        {
            rx_assert_msg(m_bulk_idx < m_max_bulk_count, "索引下标越界!已经使用bulk_bind_begin预先描述了吗?");
            switch (m_dbc_data_type)
            {
            case DT_DATE:
            {
                rx_assert(m_max_data_size == sizeof(OCIDate));
                ub1* data_buff = &m_col_databuff.at(m_bulk_idx*m_max_data_size);
                d.to(*reinterpret_cast <OCIDate*> (data_buff));
                m_col_dataempty.at(m_bulk_idx) = 0;                 //标记参数非空了
                m_col_datasize.at(m_bulk_idx) = m_max_data_size;    //记录数据的实际长度
                return (*this);
            }
            case DT_TEXT:
            {
                char tmp_buff[21];
                d.to(tmp_buff);
                return set_string(tmp_buff);
            }
            default:
                throw (error_info_t(DBEC_BAD_INPUT, __FILE__, __LINE__));
            }
        }
        //-------------------------------------------------
        //绑定文本串
        sql_param_t& set_string(PStr text)
        {
            rx_assert_msg(m_bulk_idx < m_max_bulk_count, "索引下标越界!已经使用bulk_bind_begin预先描述了吗?");
            if (is_empty(text))
            {//不管什么类型,空串都让其变为空值
                m_col_dataempty.at(m_bulk_idx) = -1;
                return *this;
            }

            switch (m_dbc_data_type)
            {
            case DT_TEXT:
            {//当前实际数据类型是文本串,赋值的也是文本,那么就进行拷贝赋值吧
                ub2 data_len = ub2(strlen(text));           //得到数据实际长度
                ub1 *data_buff = &m_col_databuff.at(m_bulk_idx*m_max_data_size);   //得到可用缓冲区
                if (data_len > m_max_data_size)             //输入数据太长了,进行截断吧
                {
                    rx_alert("输入数据过大,请在绑定时调整缓冲区尺寸");
                    data_len = ub2((m_max_data_size - 2) & ~1);
                }

                memcpy(data_buff, text, data_len);          //将输入数据拷贝到此元素对应的空间
                *((char *)data_buff + data_len++) = '\0';   //给该空间的串尾设置结束符

                m_col_dataempty.at(m_bulk_idx) = 0;         //标记参数非空了
                m_col_datasize.at(m_bulk_idx) = data_len;   //记录该元素的实际长度  
                return (*this);
            }
            case DT_DATE:
            {//当前实际数据类型是日期,而给赋值的是文本串,那么就进行转换后处理吧;默认只处理"yyyy-mm-dd hh:mi:ss"的格式
                datetime_t D;
                struct tm ST;

                if (!rx_iso_datetime(text, ST))             //转换日期格式
                    throw (error_info_t(DBEC_BAD_INPUT, __FILE__, __LINE__));
                D.set(ST);
                return set_datetime(D);                     //交给实际的功能函数
            }
            case DT_NUMBER:
            {//当前实际数据类型是数字,而给赋值的时候是文本串,那么就进行转换后处理吧
                double Value = rx::st::atof(text);
                return set_double(Value);                   //交给实际的功能函数
            }
            default:
                throw (error_info_t(DBEC_BAD_INPUT, __FILE__, __LINE__));
            }
        }
        //-------------------------------------------------
        //得到错误句柄
        OCIError* oci_err_handle() const { return m_conn->m_handle_err; }
        //得到当前的访问行号
        ub2 bulk_row_idx() const { return m_bulk_idx; }
    public:
        //-------------------------------------------------
        sql_param_t(rx::mem_allotter_i &ma) :col_base_t(ma) { clear(); }
        //-------------------------------------------------
        ~sql_param_t() { clear(); }
        //-------------------------------------------------
        //设置块访问序号
        void bulk_use(ub2 idx) 
        {
            if (idx>= m_max_bulk_count) 
                throw (error_info_t(DBEC_METHOD_CALL, __FILE__, __LINE__));
            m_bulk_idx = idx;
        }
        //获取可访问块数量
        ub2 bulk_count() { return m_max_bulk_count; }
        //-------------------------------------------------
        //让当前参数设置为空值
        void set_null() { rx_assert(bulk_row_idx() < m_max_bulk_count); m_col_dataempty.at(bulk_row_idx()) = -1; }
        bool is_null() const { rx_assert(bulk_row_idx() < m_max_bulk_count); return (m_col_dataempty.at(bulk_row_idx()) == -1); }
        //-------------------------------------------------
        //给参数的指定数组批量元素赋值:字符串值
        sql_param_t& operator = (PStr text) { return set_string(text);}
        //-------------------------------------------------
        //设置参数中指定序号的批量元素为浮点数
        sql_param_t& operator = (double value) { return set_double(value); }
        sql_param_t& operator = (long double value) { return set_real(value); }
        //-------------------------------------------------
        //设置参数为大整数值(带符号)
        sql_param_t& operator = (int64_t value) { return set_real((long double)value); }
        //-------------------------------------------------
        //设置参数为整数值(带符号)
        sql_param_t& operator = (int32_t value) { return set_long(value, true); }
        //-------------------------------------------------
        //设置参数为整数值(无符号)
        sql_param_t& operator = (uint32_t value) { return set_long(value, false); }
        //-------------------------------------------------
        //设置参数为日期时间值
        sql_param_t& operator = (const datetime_t& d) { return set_datetime(d); }
    };
}

#endif
