#ifndef _UT_RX_DBC_ORA_BASE_H_
#define _UT_RX_DBC_ORA_BASE_H_

#include "rx_tdd.h"
#include "../rx_dbc_ora.h"
#include "rx_datetime_ex.h"

using namespace rx_dbc_ora;

//---------------------------------------------------------
//测试使用的对象容器
typedef struct ut_ora
{
    conn_param_t conn_param;
    conn_t conn;

    ut_ora()
    {
        strcpy(conn_param.host, "20.0.2.106");
        strcpy(conn_param.user, "system");
        strcpy(conn_param.pwd, "sysdba");
        strcpy(conn_param.db, "oradb");
    }
}ut_ora;

//---------------------------------------------------------
//数据库连接
inline bool ut_ora_base_conn(rx_tdd_t &rt, ut_ora &dbc)
{
    try {
        dbc.conn.open(dbc.conn_param);
        dbc.conn.schema_to("HYTPDTBILLDB");
        return true;
    }
    catch (error_info_t &e)
    {
        printf(e.c_str(dbc.conn_param));
        printf("\n");
        return false;
    }
}

//---------------------------------------------------------
//简单查询
inline bool ut_ora_base_query_1(rx_tdd_t &rt, ut_ora &dbc)
{
    try {
        query_t q(dbc.conn);

        for (q.exec("select * from tmp_dbc"); !q.eof(); q.next())
        {
            printf("id(%d),int(%d),uint(%u),str(%s),mdate(%s),short(%d)\n",
                q["id"].as_long(), q["int"].as_long(), q["uint"].as_ulong(),
                q["str"].as_string(), q["mdate"].as_string(), q["short"].as_long());
        }

        for (q.exec("select * from tmp_dbc"); !q.eof(); q.next())
        {
            printf("id(%d),int(%d),uint(%u),str(%s),mdate(%s),short(%d)\n",
                q["id"].as_long(), q["int"].as_long(), q["uint"].as_ulong(),
                q["str"].as_string(), q["mdate"].as_string(), q["short"].as_long());
        }
        return true;
    }
    catch (error_info_t &e)
    {
        printf(e.c_str(dbc.conn_param));
        printf("\n");
        return false;
    }
}
//---------------------------------------------------------
//参数绑定的查询
inline bool ut_ora_base_query_2(rx_tdd_t &rt, ut_ora &dbc)
{
    try {
        query_t q(dbc.conn);

        q.prepare("select * from tmp_dbc where str=:sSTR");
        q(":sSTR","2");

        for (q.exec(); !q.eof(); q.next())
        {
            printf("id(%d),int(%d),uint(%u),str(%s),mdate(%s),short(%d)\n",
                q["id"].as_long(), q["int"].as_long(), q["uint"].as_ulong(),
                q["str"].as_string(), q["mdate"].as_string(), q["short"].as_long());
        }

        q.exec("delete from tmp_dbc where str!='str'").conn().trans_commit();

        return true;
    }
    catch (error_info_t &e)
    {
        printf(e.c_str(dbc.conn_param));
        printf("\n");
        return false;
    }
}
//---------------------------------------------------------
//绑定参数插入(使用query_t)
inline bool ut_ora_base_insert_1(rx_tdd_t &rt, ut_ora &dbc)
{
    char cur_time_str[20];
    rx_iso_datetime(cur_time_str);
    try {
        query_t q(dbc.conn);

        q.prepare("insert into tmp_dbc(id,int,uint,str,mdate,short) values(:nID,:nINT,:nUINT,:sSTR,:dDATE,:nSHORT)");
        q(":nID", 2)(":nINT", -155905152)(":nUINT",(uint32_t)2155905152u)(":sSTR", "2")(":dDATE", cur_time_str)(":nSHORT", 32769);
        q.exec();
        dbc.conn.trans_commit();
        rt.tdd_assert(q.rows() == 1);
        return true;
    }
    catch (error_info_t &e)
    {
        printf(e.c_str(dbc.conn_param));
        printf("\n");
        return false;
    }
}
//---------------------------------------------------------
//参数绑定插入示例(使用stmt_t)
inline bool ut_ora_base_insert_2(rx_tdd_t &rt, ut_ora &dbc)
{
    char cur_time_str[20];
    rx_iso_datetime(cur_time_str);
    try {
        stmt_t q(dbc.conn);
        //预处理解析
        q.prepare("insert into tmp_dbc(id,int,uint,str,mdate,short) values(:nID,:nINT,:nUINT,:sSTR,:dDATE,:nSHORT)");
        //绑定单条参数
        q(":nID", 2)(":nINT", -155905152)(":nUINT", (uint32_t)2155905152u)(":sSTR", "2")(":dDATE", cur_time_str)(":nSHORT", 32769);
        //执行语句
        q.exec();
        //提交
        dbc.conn.trans_commit();
        rt.tdd_assert(q.rows() == 1);
        return true;
    }
    catch (error_info_t &e)
    {
        printf(e.c_str(dbc.conn_param));
        printf("\n");
        return false;
    }
}
//---------------------------------------------------------
//参数绑定插入示例(使用stmt_t)
inline bool ut_ora_base_insert_2b(rx_tdd_t &rt, ut_ora &dbc)
{
    char cur_time_str[20];
    rx_iso_datetime(cur_time_str);
    try {
        stmt_t q(dbc.conn);
        //预处理解析
        q.prepare("insert into tmp_dbc(id,int,uint,str,mdate,short) values(:nID,:nINT,:nUINT,:sSTR,:dDATE,:nSHORT)");
        //绑定参数
        q(":nID")(":nINT")(":nUINT")(":sSTR")(":dDATE")(":nSHORT");
        //绑定数据
        q << 2 << -155905152 << (uint32_t)2155905152u << "2" << cur_time_str << 32769;
        //执行语句
        q.exec();
        //提交
        dbc.conn.trans_commit();
        rt.tdd_assert(q.rows() == 1);
        return true;
    }
    catch (error_info_t &e)
    {
        printf(e.c_str(dbc.conn_param));
        printf("\n");
        return false;
    }
}
//---------------------------------------------------------
//参数绑定插入示例(使用stmt_t与显示事务)
inline bool ut_ora_base_insert_2c(rx_tdd_t &rt, ut_ora &dbc)
{
    char cur_time_str[20];
    rx_iso_datetime(cur_time_str);
    try {
        rt.tdd_assert(dbc.conn.ping());

        dbc.conn.trans_begin();

        stmt_t q(dbc.conn);
        //预处理解析
        q.prepare("insert into tmp_dbc(id,int,uint,str,mdate,short) values(:nID,:nINT,:nUINT,:sSTR,:dDATE,:nSHORT)");
        //绑定参数
        q(":nID")(":nINT")(":nUINT")(":sSTR")(":dDATE")(":nSHORT");
        //绑定数据
        q << 2 << -155905152 << (uint32_t)2155905152u << "2" << cur_time_str << 32769;
        //执行语句
        q.exec();
        //再不重新绑定数据的场景,反复再次执行语句
        q.exec();
        //提交
        dbc.conn.trans_commit();
        rt.tdd_assert(q.rows() == 1);
        return true;
    }
    catch (error_info_t &e)
    {
        sword ec = 0;
        dbc.conn.trans_rollback(&ec);
        printf(e.c_str(dbc.conn_param));
        printf("\n");
        return false;
    }
}
//---------------------------------------------------------
//批量插入手动绑定示例
inline bool ut_ora_base_insert_3(rx_tdd_t &rt, ut_ora &dbc)
{
    char cur_time_str[20];
    rx_iso_datetime(cur_time_str);
    try {
        stmt_t q(dbc.conn);
        //解析带有参数绑定的语句,同时告知最大批量块深度
        q.prepare("insert into tmp_dbc(id,int,uint,str,mdate,short) values(:nID,:nINT,:nUINT,:sSTR,:dDATE,:nSHORT)").manual_bind(2);

        //给每个块深度对应的参数进行绑定与赋值
        q.bulk(0)(":nID", 2)(":nINT", -155905152)(":nUINT", (uint32_t)2155905152u)(":sSTR", "2")(":dDATE", cur_time_str)(":nSHORT", 32769);
        q.bulk(1)(":nID", 3)(":nINT", -155905152)(":nUINT", (uint32_t)2155905152u)(":sSTR", "3")(":dDATE", cur_time_str)(":nSHORT", 32769);
        //执行本次批量操作
        q.exec();
        rt.tdd_assert(q.rows() == 2);
        //必须对默认事务进行提交
        dbc.conn.trans_commit();

        //继续进行批量数据的绑定
        q.bulk(0)(":nID", 4)(":nINT", -155905152)(":nUINT", (uint32_t)2155905152u)(":sSTR", "2")(":dDATE", cur_time_str)(":nSHORT", 32769);
        //告知真正绑定的数据深度并执行操作
        q.exec(1);
        rt.tdd_assert(q.rows() == 1);
        //必须对默认事务进行提交
        dbc.conn.trans_commit();
        return true;
    }
    catch (error_info_t &e)
    {
        printf(e.c_str(dbc.conn_param));
        printf("\n");
        return false;
    }
}
//---------------------------------------------------------
//进行自动参数绑定的插入示例
inline bool ut_ora_base_insert_4(rx_tdd_t &rt, ut_ora &dbc)
{
    char cur_time_str[20];
    rx_iso_datetime(cur_time_str);
    try {
        stmt_t q(dbc.conn);

        //预处理解析并进行参数的自动绑定
        q.prepare("insert into tmp_dbc(id,int,uint,str,mdate,short) values(:nID,:nINT,:nUINT,:sSTR,:dDATE,:nSHORT)").auto_bind();
        q << 2 << -155905152 << (uint32_t)2155905152u << "2" << cur_time_str << 32769;   //顺序给参数进行数据赋值
        q.exec().conn().trans_commit();                     //执行语句并提交

        rt.tdd_assert(q.rows() == 1);
        return true;
    }
    catch (error_info_t &e)
    {
        printf(e.c_str(dbc.conn_param));
        printf("\n");
        return false;
    }
}
//---------------------------------------------------------
//进行自动参数绑定的批量插入示例
inline bool ut_ora_base_insert_5(rx_tdd_t &rt, ut_ora &dbc)
{
    char cur_time_str[20];
    rx_iso_datetime(cur_time_str);
    try {
        stmt_t q(dbc.conn);
        //解析带有参数绑定的语句,同时告知最大批量块深度
        q.prepare("insert into tmp_dbc(id,int,uint,str,mdate,short) values(:nID,:nINT,:nUINT,:sSTR,:dDATE,:nSHORT)").auto_bind(2);

        //给每个块深度对应的参数进行赋值
        q.bulk(0) << 2 << -155905152 << (uint32_t)2155905152u << "2" << cur_time_str << 32769;
        q.bulk(1) << 3 << -155905152 << (uint32_t)2155905152u << "3" << cur_time_str << 32769;
        q.exec().conn().trans_commit();                     //执行本次批量操作,并进行提交
        rt.tdd_assert(q.rows() == 2);

        //继续进行批量数据的绑定
        q.bulk(0) << 4 << -155905152 << (uint32_t)2155905152u << "2" << cur_time_str << 32769;
        q.exec(1, true);                                    //告知真正绑定的数据深度,执行并提交
        rt.tdd_assert(q.rows() == 1);

        return true;
    }
    catch (error_info_t &e)
    {
        printf(e.c_str(dbc.conn_param));
        printf("\n");
        return false;
    }
}
//---------------------------------------------------------
//sql绑定参数解析示例
inline void ut_ora_base_sql_parse_1(rx_tdd_t &rt)
{
    sql_param_parse_t<> sp;
    rt.tdd_assert(sp.ora_sql("select id,'b',':g:\":H:\":i:',\"STR\",':\" : a\":\" : INT\"',UINT from tmp_dbc where id=:nID and UINT=:nUINT;") == NULL);
    rt.tdd_assert(sp.count == 2);
    rt.tdd_assert(strncmp(sp.segs[0].name, ":nID", sp.segs[0].name_len) == 0);
    rt.tdd_assert(sp.segs[0].name_len == 4);
    rt.tdd_assert(strncmp(sp.segs[1].name, ":nUINT", sp.segs[1].name_len) == 0);
    rt.tdd_assert(sp.segs[1].name_len == 6);

    rt.tdd_assert(sp.ora_sql("select id,:se'b',':g:\":H:\":i:',\"STR\",':\" : a\":\" : INT\"',UINT from tmp_dbc where id=:nID and UINT=:nUINT;") != NULL);

    rt.tdd_assert(sp.ora_sql("select id,'b':se,':g:\":H:\":i:',\"STR\",':\" : a\":\" : INT\"',UINT from tmp_dbc where id=:nID and (UINT=:nUINT)") != NULL);
    rt.tdd_assert(sp.ora_sql("select id,'b' :se,':g:\":H:\":i:',\"STR\",':\" : a\":\" : INT\"',UINT from tmp_dbc where id=:nID and (UINT=:nUINT)") == NULL);
    rt.tdd_assert(sp.count == 3);

    rt.tdd_assert(sp.ora_sql("select id,'b',':g:\":H:\":i:',:se,\"STR\",':\" : a\":\" : INT\"',UINT from tmp_dbc where id=:nID and UINT=:nUINT;") == NULL);
    rt.tdd_assert(sp.count == 3);

    rt.tdd_assert(sp.ora_sql("select id,'b',':g:\":H:\":i:',:se"",\"STR\",':\" : a\":\" : INT\"',UINT from tmp_dbc where id=:nID and UINT=:nUINT") == NULL);
    rt.tdd_assert(sp.count == 3);

    rt.tdd_assert(sp.ora_sql("select id,'b',':g:\":H:\":i:',:se\"\",\"STR\",':\" : a\":\" : INT\"',UINT from tmp_dbc where id=:nID and UINT=:nUINT;") != NULL);

    rt.tdd_assert(sp.ora_sql("select id,'b',':g:\":H:\":i:',\"STR\",':\" : a\":\" : INT\"',UINT:se from tmp_dbc where id=:nID and UINT=:nUINT;") != NULL);

    rt.tdd_assert(sp.ora_sql("select id,'\"',UINT:se from tmp_dbc where id=:nID and UINT=: nUINT;") != NULL);
    rt.tdd_assert(sp.ora_sql("select id,'\"',UINT :se from tmp_dbc where id=:nID and UINT=:nUINT;") == NULL);   //解析通过,但不符合sql语法
    rt.tdd_assert(sp.ora_sql("select id,'\"',UINT from tmp_dbc where id=1 and UINT=1") == NULL); 
    rt.tdd_assert(sp.count==0);

    char tmp[1024];
    rt.tdd_assert(sp.ora_mysql("select id,'\"',UINT from tmp_dbc where id=1 and UINT=1",tmp,sizeof(tmp)) != sizeof(tmp)); 

    rt.tdd_assert(sp.ora_mysql("select id,'b',':g:\":H:\":i:',:se,\"STR\",':\" : a\":\" : INT\"',UINT from tmp_dbc where id=:nID and UINT=:nUINT;",tmp,sizeof(tmp)) != sizeof(tmp));

}
//---------------------------------------------------------
//进行数据库基础动作测试
inline void ut_ora_base_1(rx_tdd_t &rt)
{
    ut_ora ora;
    if (ut_ora_base_conn(rt, ora))
    {
        rt.tdd_assert(ut_ora_base_insert_2c(rt, ora));

        rt.tdd_assert(ut_ora_base_query_1(rt, ora));

        rt.tdd_assert(ut_ora_base_insert_1(rt, ora));
        rt.tdd_assert(ut_ora_base_insert_2(rt, ora));
        rt.tdd_assert(ut_ora_base_insert_2b(rt, ora));
        rt.tdd_assert(ut_ora_base_insert_2c(rt, ora));
        rt.tdd_assert(ut_ora_base_insert_3(rt, ora));
        rt.tdd_assert(ut_ora_base_insert_4(rt, ora));
        rt.tdd_assert(ut_ora_base_insert_5(rt, ora));

        for (int i = 0; i < 10; ++i)
            rt.tdd_assert(ut_ora_base_query_1(rt, ora));

        rt.tdd_assert(ut_ora_base_query_2(rt, ora));
    }
}

//---------------------------------------------------------
typedef struct ut_ins_dat_t
{
    uint32_t    ID;
    int32_t     INT;
    uint32_t    UINT;
    char        STR[20];
    char        DATE[20];
    int16_t     SHORT;
    
    ut_ins_dat_t() 
    {
        ID = (uint32_t)rx_time();
        INT = -155905152;
        UINT = 2155905152u;
        sprintf(STR,"%x",ID);
        rx_iso_datetime(DATE);
        SHORT = (int16_t)ID;
    }
}ut_ins_dat_t;

//DBC事件委托对应的函数指针类型;//返回值:<0错误; 0用户要求放弃; >0完成,批量深度
inline int32_t ut_dbc_event_func_1(query_t &q, void *usrdat)
{
    ut_ins_dat_t &dat = *(ut_ins_dat_t*)usrdat;
    q << dat.ID << dat.INT << dat.UINT << dat.STR << dat.DATE << dat.SHORT;
    return 1;
}

inline void ut_ora_ext_1(rx_tdd_t &rt)
{
    //定义数据库连接
    dbc_conn_t conn;
    conn.set_conn_param("20.0.2.106", "system", "sysdba");
    rt.tdd_assert(conn.schema_to("HYTPDTBILLDB"));

    //定义待处理数据
    ut_ins_dat_t dat;

    //定义数据库功能对象,告知数据绑定函数与数据对象
    dbc_exec_t dbc(conn, ut_dbc_event_func_1, &dat);

    //首次执行sql语句,使用构造时给定的数据
    int rc=dbc("insert into tmp_dbc(id,int,uint,str,mdate,short) values(:nID,:nINT,:nUINT,:sSTR,:dDATE,:nSHORT)");
    rt.tdd_assert(rc>0);

    //更换数据对象后再次执行
    ++dat.ID;
    rc = dbc(&dat);
    rt.tdd_assert(rc>0);

    //更换数据对象后再次执行
    ++dat.ID;
    rc = dbc(NULL,&dat);
    rt.tdd_assert(rc>0);
}
//---------------------------------------------------------
//使用dbc_t作为基类进行业务处理
class mydbc :public dbc_t
{
    //!!关键!!进行参数数据的绑定动作;
    //返回值:<0错误;0用户要求放弃;>0完成
    virtual int32_t on_bind_data(query_t &q, void *usrdat)
    {
        ut_ins_dat_t &dat = *(ut_ins_dat_t*)usrdat;
        q << dat.ID << dat.INT << dat.UINT << dat.STR << dat.DATE << dat.SHORT;
        return 1;
    }
public:
    mydbc(dbc_conn_t  &c) :dbc_t(c) {}
};
inline void ut_ora_ext_2(rx_tdd_t &rt)
{
    //定义数据库连接
    dbc_conn_t conn;
    conn.set_conn_param("20.0.2.106", "system", "sysdba");
    rt.tdd_assert(conn.schema_to("HYTPDTBILLDB"));

    //定义待处理数据
    ut_ins_dat_t dat;

    //定义数据库功能对象,告知数据绑定函数与数据对象
    mydbc dbc(conn);

    //首次执行sql语句,并告知数据
    int rc = dbc("insert into tmp_dbc(id,int,uint,str,mdate,short) values(:nID,:nINT,:nUINT,:sSTR,:dDATE,:nSHORT)", &dat);
    rt.tdd_assert(rc>0);

    //更换数据对象后再次执行
    ++dat.ID;
    rc = dbc.exec(&dat);
    rt.tdd_assert(rc>0);

    //更换数据对象后再次执行
    ++dat.ID;
    rc = dbc.exec(&dat);
    rt.tdd_assert(rc>0);
}
//---------------------------------------------------------
rx_tdd(ut_dtl_array)
{
    ut_ora_ext_1(*this);
    ut_ora_ext_2(*this);

    ut_ora_base_sql_parse_1(*this);
    ut_ora_base_1(*this);
    for(int i=0;i<10;++i)
        ut_ora_base_1(*this);
}

#endif
